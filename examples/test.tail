# primes_to m ->
#   eratos lst ->
#     const p -> head lst
#     const ps -> tail lst
#     const pp -> mul p p

#     if gt pp m then
#       lst
#     else
#       [p] ++ (eratos (minus ps [pp..=m, p]))

#   eratos [2..=m]

# minus a b ->
#   if eq (len a) 0 then
#     a
#   elif eq (len b) 0 then
#     a
#   else
#     const x -> head a
#     const y -> head b

#     case compare x y of
#       "lt" => [x] ++ (minus (tail a) b)
#       "eq" => minus (tail a) (tail b)
#       "gt" => minus a (tail b)

# const to -> 700
# const primes -> primes_to to
# trace $"{{len primes}} primes to {{to}}: {{primes}}"


memoize f ->
  const memo -> mrecord_new {}

  !x ->
    const sx -> str x

    if mrecord_has memo sx then
      mrecord_read memo sx
    else
      mrecord_write memo sx (f x)

fib_inner n -> if lt n 2 then
  n
else
  add (fib (sub n 1)) (fib (sub n 2))

const fib -> memoize &fib_inner

trace (fib 6)
